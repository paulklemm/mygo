---
title: GO-Term Analysis
date: "`r Sys.Date()`"
output:
  flexdashboard::flex_dashboard:
    fig_width: 14
    fig_height: 10
    toc_float: yes
    code_folding: hide
params:
  dat: ''
  output_path: '.'
  save_excel: TRUE
  significance_cutoff: 0.05
  simplify_ontologies: TRUE
  do_gse: TRUE
  use_background: TRUE
  store_r_objects: TRUE
  simplify_cutoff: 0.7
---

# Overview

## Column {.tabset}

Conduct GO-term analysis using [clusterProfiler](https://guangchuangyu.github.io/software/clusterProfiler/) and print report.

### Restrictions & Data Preparations

Currently only `mus musculus` datasets are supported.

The data frame input needs to have the following dimensions:

- `ensembl_gene_id` or `EntrezID` (`character`)
- `q_value` (`numeric`)
- `fc` (`numeric`)
- `Symbol` (`character`) (optional, but it's easier to identify genes that cannot be associated with an EntrezID)

```{r setup, echo = FALSE, message = TRUE, warning = TRUE, results = 'asis'}

# Retreive parameter settings

rmd_params <- list()

rmd_params$dat <- params$dat
rmd_params$output_path <- params$output_path
rmd_params$save_excel <- params$save_excel
rmd_params$significance_cutoff <- params$significance_cutoff
rmd_params$simplify_ontologies <- params$simplify_ontologies
rmd_params$do_gse <- params$do_gse
rmd_params$use_background <- params$use_background
rmd_params$store_r_objects <- params$store_r_objects
rmd_params$simplify_cutoff <- params$simplify_cutoff

library(mygo)
library(magrittr)
library(tibble)
library(knitr)

# Print settings as table
tibble::tibble(
  name = c("output_path", "save_excel", "significance_cutoff", "simplify_ontologies", "do_gse", "use_background", "store r objects", "simplify cutoff"),
  setting = c(rmd_params$output_path, rmd_params$save_excel, rmd_params$significance_cutoff, rmd_params$simplify_ontologies, rmd_params$do_gse, rmd_params$use_background, rmd_params$store_r_objects, rmd_params$simplify_cutoff)
) %>%
  knitr::kable()

# Summary for parameter file
print("Data table head:")
rmd_params$dat %>%
  head() %>%
  knitr::kable()
paste0("dat contains ", rmd_params$dat %>% nrow(), " rows.")

if (!('q_value' %in% colnames(rmd_params$dat))) {
  stop('Column `q_value` not found in data frame')
} else if (!('fc' %in% colnames(rmd_params$dat))) {
  stop('Column `fc` not found in data frame')
}

# Filter significant genes
if (!('EntrezID' %in% colnames(rmd_params$dat))) {
  warning('EntrezID not available in data frame. Attaching it manually')
  dat <- rmd_params$dat %>%
    ensembl_to_entrez(ensembl_id_name = "ensembl_gene_id", keep_only_rows_with_entrez = TRUE, drop_duplicates = TRUE) %>%
    attach_gene_symbol_from_entrez()
  
  # Get regulated genes that don't have a EntrezID
  # https://github.sf.mpg.de/bruening-lab/2018-01-Weiyi-Differential-Gene-Expression-Analysis/blob/master/Analysis_DESeq.Rmd
  print("Regulated genes that do not map to a EntrezID")
  rmd_params$dat %>%
    dplyr::filter(q_value <= rmd_params$significance_cutoff) %>%
    dplyr::anti_join(dat %>% dplyr::filter(q_value <= rmd_params$significance_cutoff), by = "ensembl_gene_id") %>%
    # Attach gene name from Biomart entry
    rmyknife::attach_biomart(attributes = "external_gene_name", verbose = FALSE) %>%
    knitr::kable() %>%
    print()
  
  print("Check for genes with duplicated entries. We will consider the ones with the lowest p-value")

  dat %<>% add_is_duplicated("EntrezID")
  dat %>%
    dplyr::filter(EntrezID_is_duplicated == T) %>%
    knitr::kable() %>%
    print()
  
  dat %<>%
    # For duplicated Entrez IDs only keep the ones with the lowest p-value
    dplyr::group_by(EntrezID) %>%
    dplyr::summarize(q_value = min(q_value)) %>%
    # Join back with the original data set in which we will also remove entries that have the same EntrwzID, q-value and FC
    # Because it can happen that a EntrezID maps to different Ensembl-IDs
    dplyr::inner_join(dat %>% dplyr::distinct(EntrezID, q_value, fc, .keep_all = TRUE))
  # Finally check if we still have problems regarding multiple entries
  .temp_multiple_entries <- dat %>% add_is_duplicated('EntrezID') %>% dplyr::filter(EntrezID_is_duplicated == T)
  if (nrow(.temp_multiple_entries) > 0) {
    warning("Duplicates per EntrezID, check input data")
    .temp_multiple_entries %>% kable()
  }
  # Remove obsolete rows
  dat %<>% dplyr::select(-EntrezID_is_duplicated)
}
# Get names vector from EntrezIDs
# dat %<>% attach_gene_symbol_from_entrez()
# Named double vector of fold changes named after the gene symbol 
fc_symbol <- dat %>%
  .$fc %>%
  as.double() %>%
  `names<-`(dat$Symbol)
```

### Volcano Plot

To get a general feeling for the data we plot the differential expression analysis result as Volcano Plot.

```{r volcano_plot}
dat %>% volcano_plot()
```

# GO-Term Analysis

## Column {.tabset}

### Overview

Also called GO-over represenation test.

* We use the over-representation test implemented in clusterProfiler and [described here](https://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html#go-over-representation-test)
* The over-representation test is carried out internally with the DOSE package and is [described here](https://bioconductor.org/packages/release/bioc/vignettes/DOSE/inst/doc/enrichmentAnalysis.html#over-representation-analysis)
* For details on the hypergeometric distribution, refer to [GO::TermFinderâ€”open source software for accessing Gene Ontology information and finding significantly enriched Gene Ontology terms associated with a list of genes](https://academic.oup.com/bioinformatics/article/20/18/3710/202612)
  * Hypergeometric distribution is a distribution modelling normally distributed probabilities (e.g. red, blue and green marbles in a Urn) -- [Wiki](https://de.wikipedia.org/wiki/Hypergeometrische_Verteilung)
  * Freely spoken, DOSE determines whether any terms annotated by the list of differentially expressed genes is greater than the one expected by chance in a term

### All

```{r get_go_and_gse}

# Expect a data set containing q_values and Entrez/Ensembl IDs
dat_goterms <- dat %>% get_go_all_ontologies(
  significance_cutoff = rmd_params$significance_cutoff,
  use_background = rmd_params$use_background
)
# Get simplified ontologies if required
if (rmd_params$simplify_ontologies) {
  dat_goterms_simplified <- simplify_ontologies(
    ontologies = dat_goterms,
    cutoff = rmd_params$simplify_cutoff
  )
}
if (rmd_params$do_gse) {
  dat_gse_go <- dat %>% get_gse_all_ontologies()
  dat_gse_kegg <- dat %>% get_kegg()
} else {
  dat_gse_go <- list()
  dat_gse_go$Biological_Process <- tibble::tibble()
  dat_gse_go$Molecular_Function <- tibble::tibble()
  dat_gse_go$Cellular_Components <- tibble::tibble()
  dat_gse_kegg <- list()
  dat_gse_kegg$kegg <- tibble::tibble()
}
```

```{r plot_go}
dat_goterms %>% plot_all_ontologies(fc_symbol)
```

### Simplified

ClusterProfiler allows usage of the `simplify` method that removes redundant GO terms. For details, refer to [this blog post](https://guangchuangyu.github.io/2015/10/use-simplify-to-remove-redundancy-of-enriched-go-terms/).

```{r print_go_ontologies}
if (rmd_params$simplify_ontologies) {
  dat_goterms_simplified %>% plot_all_ontologies(fc_symbol)
} else {
  print("Simplified ontologies deactivated.")
}
```

# Gene Set Enrichment (GSE) Analysis

## Column {.tabset}

### GSE GO Analysis

* The GO-overrepresentation test can miss subtle changes in terms, for example when all genes in a term are up-regulated, but not enough the render each gene differentially regulated
* The GSEA uses all genes to detect changes where all genes in a predefined set change in a small but coordinated way
* Implemented in clusterProfiler and [described here](https://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html#go-gene-set-enrichment-analysis)
* The original paper is [Gene set enrichment analysis: A knowledge-based approach for interpreting genome-wide expression profiles](http://www.pnas.org/content/102/43/15545.long)

```{r gse_all}
if (rmd_params$do_gse) {
  dat_gse_go %>% plot_all_ontologies(fc_symbol)
} else {
  print("GSE analysis disabled")
}
```

### GSE KEGG Pathways

Here we apply the GSE analysis to KEGG pathways.

```{r gse_kegg_all}
if (rmd_params$do_gse) {
  dat_gse_kegg %>% plot_all_ontologies(fc_symbol)
} else {
  print("GSE analysis disabled")
}
```

```{r export_result}
# Create dummy variable for for simplified gene ontologies if we did not calculate it
if (!rmd_params$simplify_ontologies) {
  dat_goterms_simplified <- data.frame()
}

# Store clusterProfiler objects to disk
if (rmd_params$store_r_objects) {
  dat_goterms %>%
    saveRDS(file = file.path(rmd_params$output_path, "dat_goterms.rds"))
  
  if (rmd_params$do_gse) {
    dat_gse_go %>%
      saveRDS(file = file.path(rmd_params$output_path, "dat_gse_go.rds"))
    dat_gse_kegg %>%
      saveRDS(file = file.path(rmd_params$output_path, "dat_gse_kegg.rds"))
  }
  if (rmd_params$simplify_ontologies) {
    dat_goterms_simplified %>%
      saveRDS(file = file.path(rmd_params$output_path, "dat_goterms_simplified.rds"))
  }
}

# Export result
if (rmd_params$save_excel) {
  export_go_terms_to_excel(
    go_ontologies        = dat_goterms,
    go_ontologies_simple = dat_goterms_simplified,
    gse_ontologies       = dat_gse_go,
    kegg_ontologies      = dat_gse_kegg,
    path                 = paste0(rmd_params$output_path, '/go_terms.xlsx')
  )
}
```
